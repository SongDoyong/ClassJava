import java.util.Arrays;

/*
			배열 : 같은 데이터를 모아서 관리 
				  ---------
			
			변수	--------
				   10   -> a   ==> int a=10; // 하나의 데이터를 저장하는 변수
				--------		   ---  기본형 (자바에서 지원하는 데이터형)	   => 낱 개로 저장하면, 관리가 어려움
			
			배열 => 연속적으로 메모리를 배치하므로, 인덱스 번호를 이용
				arr[0], arr[1] ....  	
				-----------------------------
				  1	| 2	| 3	| 4	| 5	| 6	| 7	|
				|----------------------------
			  배열명
			
				
				★★★자바의 메모리 구조★★★
			--------------------------------
			Method Area : method, static 저장
			--------------------------------
			Stack : 메모리 관리 (지역변수, 매개변수)
					--> 지금까지 지역변수 사용 ({ }을 벗어나면 사라짐)
			--------------------------------
			Heap : 동적 메모리 할당 (new)
							=> 배열 / 클래스
			--------------------------------

		1. 배열 선언 : 데이터형 [] 배열명 = {};
					 데이터형 배열명 [];
					 데이터형 [] 배열명 = new 데이텨형 [배열 갯수];
		
		2. 배열 할당 : 연속적으로 몇 개를 만들지 여부
					 데이터형 [] 배열명 = new 데이텨형 [배열 갯수];				// new: 실행할 때마다 메모리를 할당
					 				  ---- malloc(sizeof(10)) => 연산자로 승격 why? 자주 사용되서
										delete
											free() ---> 개발자의 사용빈도 少 -> GC(garbage collection)
											GC => 사용하지 않거나 / null 값일 경우 자동 회수
											System.gc() => 사용하지 않는 메모리를 바로 회수하도록 ex) 영상 종료
					
					데이터형 [] 배열명 = new 데이텨형 [크기 결정];
								ex) int[] arr=new int[5];
									---------  ---------------------------
									  Stack		Heap (실제 데이터가 저장되는 곳)
									---------  ---------------------------
									
									arr
									-----	---[0]-[1]-[2]-[3]-[4]-- index
									0x100		0 | 0 | 0 | 0 | 0 
									-----	|-----------------------
									  |	  0x100
									  |
									 new
									실제 저장된 데이터의 메모리 주소를 이용해서 데이터 관리 (참조변수)
												=> 배열 / 클래스 
		
								cf) stack에 저장된 배열은 사라지지만, heap에 저장된 데이터는 사라지지 않기 때문에,
										GC를 활용하여 데이터를 지울 필요가 있음
						
		3. 초기화 		=========================>	변수(변수 / 배열 / 클래스)는 초기화 후에 사용해야 함
			1) 인덱스 이용												-----
				int[] arr=new in[3];								  |
				arr[0]=10;		-----[0]---[1]---[2]-----			  |
				arr[1]=20;			  0	    0	  0 --> 초기화		  |
				arr[2]=30;			 10    20    30					  |
								-------------------------			  ㅇ
																클래스의 저장공간
															-----------------------		여러 정보(데이터형)를 클래스 하나에 저장 => 많이 쓰임
																---------------							ex)영화정보, 회원정보, 게시물
																	  10						
																---------------
																	 10.5
																---------------
																	"홍길동"
																---------------
															-----------------------
																	
			2) for문 이용	
				for(int i=0;i<arr.length;i++)				
				{
					arr[i]=(i+1)*10;
				}
				-----[0]---[1]---[2]-----
					  0	    0	  0 --> 초기화
					 10    20    30
				-------------------------
			
			3) 선언과 동시에 초기화
				ex) 영화 / 음악 ... (파일, 오라클, 크롤링 등 활용)
					int[] arr=	{1,2,3,4,5,}; => [ ] (javascript의 경우, 중괄호(블록)가 아닌 대괄호!)
					char[] c =	{'A','B',...};
					String[] s=	{" ", " ", " ", " ", " "}; => 웹에서 80% 이상 차지하는 변수 String
	
	
			단점) 배열은 고정되어있음 => 확장을 위해서는 새로운 배열을 생성하고, 데이터 자체를 옮겨야 함.
						-얕은 복사 :	주소를 동일하게 만듦	
									int[] arr1={ };
									int[] arr2=arr1;  => 같은 주소를 참조하므로, 수정시 데이터가 같이 변함
						-깊은 복사 : 	새로운 주소를 만듦
								1)	int[] arr1={ };
									int[] arr2=arr.clone( );	=> 다른 주소를 형성, 메모리 값 자체를 복사 (같은 크기)
									
								2)	arraycopy()					=> 배열을 확장할 경우 사용
								3)	for를 이용해서 데이터 값을 복사
		
		*** new를 이용하는 경우 => 기본 디폴트 값 설정
		
		int[] 		==> 0
		char[] 		==> '\u0000'
		String[]	==> null (모든 클래스의 기본 디폴트는 null)	--> 메모리 주소가 없는 경우 (NullPointeException)
		double[]	==> 0.0
		boolean[]	==> false
		
*/


public class _01_배열응용_이론복습 {
	public static void main(String[] args) {
		// char 배열 선언 => 26(갯수) ==> 초기값 A~Z
		char[] alpha=new char[26];
		// 초기화
		char c='A';
		for(int i=0;i<alpha.length;i++)
		{
			alpha[i]=c++;
		}
		// 출력
		for(char cc:alpha)  // 배열, 컬렉션
		{
			 System.out.print(cc+"  ");
		}
		System.out.println();
		System.out.println(Arrays.toString(alpha));	// Arrays.toString 으로 출력하기보다, for-each(향상된 for)를 활용하는 연습
		
	}
}
