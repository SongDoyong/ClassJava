package com.sist.main;


/*
		자바 클래스의 구성	=> 	객제치향 특성 (접근지정어 / 캡슐화 / 재사용법 / 수정 / 추가)
		--------------	접근지정어: public / protected / default / private
									1) 변수	2) 메소드	  3) 생성자
										1- 캡슐화: 데이터 보호 => 모든 변수는 private
										2- 재사용: 변경해서 사용 or 있는 그대로 사용
												(상속 is-a)		(포함 has-a)
										3- 수정: 오버라이딩	  /  추가: 오버로딩
									
		class ClassName			
		{
		----------------------------------------
		 변수
		  1) 멤버변수 (인스턴스 변수) -> new 메모리에 저장할 때 따로 저장되는 변수
		  		형식) [접근지정어] 데이터형 변수명 = 값 (or 디폴트값)
		  			ex) int a;		-> 디폴트 0
		  				int a=10;	-> 값 10	(명시적 초기화)
		  			  int a; a=10; => 오류 (class 영역에서는 구현x)
		  			  	  변수의 초기화를 위한 <생성자>
		  			  	-> 생성시점: new를 이용해서 메모리 공간이 확보될 때
		  			  	-> 소멸시점: 객체=null이거나 사용하지 않는 경우
		  			  	 		   -------------- 가비지컬렉션이 자동 소멸시킴 (메모리 회수)
		  			  => 가장 많이 사용되는 변수! (데이터 여러 개를 저장)
		  		사옹방법)
		  			class A					MusicData music=new MusicData();
		  			{
		  				int age;	-> 0
		  				String name;-> null
		  			}
		  			A a = new A(); 	-> age, name을 저장할 공간 형성
		  				  ----
		  				 -> a.age	-> 사용을 위해서는 a.age
		  				 	a.name				   주소.데이터								인스턴스: 메모리에 저장된 상태
		  				 						------ 주소를 가지고 있기 때문에, 변수라는 표현 불가 -> 객체 혹은 인스턴스라고 부름
		  				 											age는 객체변수 혹은 인스턴스 변수
		  			A b = new A();	-> age, name을 저장할 공간 또 형성
		  				-> b.age / b.name
		  			=============================> class는 한 개만 설계 -> new를 이용해서 여러 개 저장
		  			-a-|	a------------------------		-b-|	b------------------------	
		  			100|  => age-----------------			200|  => age-----------------
		  			---|			25						---|			20
		  					name-----------------					name-----------------
		  							홍길동									심청이
		  						-----------------						-----------------
		  					-------------------------				-------------------------
		  				
		  				b=a;	-b-|	b------------------------	X	-a-|	a------------------------
		  						100|  	 age-----------------		X	100|  => age-----------------
		  						---|			20					X	---|			25				
		  								name-----------------		X			name-----------------	
		  										심청이				X					홍길동		
		  									-----------------		X				-----------------
		  								-------------------------	X			-------------------------
		  						-> 가비지 컬렉션에 의해 사용되지 않는 200 주소는 삭제
		  							b는 100 주소지를 참조하므로 기존에 저장된 데이터 사라짐
		  							메모리 주소의 복구가 어려움
		  							저장된 데이터 관리 위치가 변경될 수 있기 때문에, 주소지 참조를 바꾸는 것은 지양해야함
		  		
		  		
		  2) 정적변수 (클래스변수, 공유변수) -> 한 개의 공간만 생성 static
		  		=> 공유변수: 오라클
		  		 형식: [접근지정어] static 데이터형 변수명 = 값 (or 디폴트값)
		  		 		int - 0 / double - 0.0 / boolean - false / String, 배열, class - null(주소가 없는 상태)
		  		 		 -> 생성시점: 컴파일러에 의해 자동으로 메모리에 저장
		  		 		 -> new가 없어도 사용 가능
		  		 		 
		  		 		
		----------------------------------------			
		 생성자
		 	1) 객체가 생성될 때, 호출되는 메소드
		 		A a = new A();
		 				  --- 생성자
		 	2) 특징
		 		-클래스명과 동일함
		 		-리턴타입이 없음
		 		-생성자가 없는 경우 추가(매개변수가 없는 생성자 - default생성자, 기본생성자)
		 		-멤버변수의 초기화
		 		-생성자는 여러 개 사용 가능 (한 개의 클래스)
		 		-자동 추가되는 것들
		 		 	-------
		 		 	import java.lang.*
		 		 		   ----------- String, Math, System 등등
		 		 	class A extends Object (클래스 형성시, superclass에 java.lang.Object를 상속받는 중)
		 		 			--------------
		 		 	생성자 (기본 생성자)
		 		 	return (void 메소드일 경우)
		 		 
		 			class A
		 			{
		 				A(){}			***생성자
		 				void A(){}		일반메소드	(리턴 타입이 붙어있음)
		 				A(int a){}		***생성자 
		 				A(int a,int b){}***생성자
		 			}
		 	3) 역할
		 		-시작과 동시에 처리
		 			ex) 자동 로그인
		 				오라클 연결
		 				서버 연결
		 		-멤버변수의 초기화
		 			class A						class A
		 			{                           {
		 				int a;                  	int a;
		 			//	a=10;-> 오류나는 코딩   
		 				A()                     	A()
		 				{                       	{
		 					a=10;               		// 파일 읽기, 크롤링 ... -> 구현해서 초기화 할 때!
		 				}                       	}
		 			}                           }
		 			=> 필요할 때만 사용 (생략 가능)
		 							---------- 컴파일러에 의해 자동으로 추가
		 			
		----------------------------------------
		 메소드
		 	1) 역할: 다른 클래스, 클래스와 통신 (연결)
		 	2) 수정 / 추가 (오버라이딩 / 오버로딩)
		 	3) 반복제거
		 	4) 구조적인 프로그램 (단락 나누기) => 오류, 수정 편리하도록
		 	5) 메소드는 호출시마다 처음부터 끝까지 사용
		 	6) 구성요소
		 		결과값(리턴타입)
		 			=> 리턴타입으로 사용되는 데이터형
		 				기본형													기본형: 자바에서 지원 but! 지원하지 않는 것이 많음
		 				int / double / char / boolean / long					클래스: 프로그래머가 만들어서 처리하는 것
		 				배열: 같은 데이터형 여러 개										-> 사용자 정의 데이터형
		 				int[] / double[]											-> 형변환, 대입 가능 (기본형과 동일하게 사용 가능)
		 				클래스: 다른 데이터형 여러 개
		 				String / 사용자정의 클래스
		 					-> 클래스도 배열로 사용 가능 (클래스를 데이터형으로 생각하기)
		 				
		 		메소드명: 식별자 -> 변수, 클래스, 인터페이스, 메소드
		 				=> 변수, 메소드는 소문자
		 				=> 클래스, 인터페이스는 대문자
		 				=> 문자 길이는 상관없음 
		 				=> 가급적 한글 사용x (리눅스에서 한글 호환x)
		 				
		 		매개변수(사용자 요청값)
		 		*** 사용자의 요청값을 받아서 요청 처리 결과값을 도출
		 		*** 최소화 시키기 (3개 이상 -> 배열 or 클래스)
		 		 ex)
		 		 	정수 10개를 보내주고, 정렬해서 가져오라 (사용자 요청)
		 		 	(int a, int b, int c... -> x)
		 		 	(int[] arr -> o)
		 		 	회원가입
		 		 	(String id, String pwd, String name, Stirng sex
		 		 	 int age, String add1 .....)
		 		 	(Member m -> 클래스)
		 		 	
		 		 메소드 유형
		 		 	=> 리턴타입 (없거나, 단 1개만 존재)
		 		 				-> 여러 개의 값을 넘기기 위해서는 배열 / 클래스를 리턴하기
		 		 	=> 매개변수 (없거나, 1개 이상 존재)
		 		 -----------------------
					리턴타입		매개변수
		 		 -----------------------
		 		 	  O			  O		==> 가장 많이 사용
		 		 	  자바 자체에서 처리(main 코딩) / 자바에서 브라우저로 데이터 보내기
		 		 -----------------------
		 		 	  O			  X		
		 		 -----------------------
					  X			  O
		 		 -----------------------
					  X			  X
		 		 -----------------------
		 		 
		 		 메소드 형식
		 		 [접근지정어][옵션] 리턴타입 메소드명 (매개변수)		<선언부>
		 		 {
		 		 	옵션: static / abstract / final
		 		 	<구현부>
		 		 	연산 / 제어
		 		 	return 값; => void의 경우 생략 가능
		 		 }
		 		 
		----------------------------------------
		}

		
		
		1.method Area
			-> static(공유변수)
		2.stack
			-> 지역변수, 매개변수 ==> 메모리 자체 관리 (생성시점: 메소드 호출 / 소멸시점: 메소드 호출 종료, {} 종료)
		3.heap
			-> 인스턴스, 배열 ==> 프로그래머, GC가 관리 / 프로그램 종료
		
		class A
		{
			int a;				-> 메모리 저장 x 		-> 저장을 위해서 new 사용 필요
			static int b;		-> 컴파일러가 자동으로 메모리 저장
			
		}
		
		A aa = new A();	-> aa라는 주소에 클래스 A만큼의 데이터를 저장하는 공간 형성
						   aa라는 주소 속에는 int a가 저장되어 있음
		A bb = new A();	-> bb라는 주소에 클래스 A만큼의 데이터를 저장하는 공간 형성
						   bb라는 주소 속에는 int a가 저장되어 있음
					static int b는 메소드 에어리어 내에 따로 생성되어 있으므로, aa와 bb는 메소드 에어리어에서 int b를 참조하여 사용
								(만약, static int b의 값을 변경하면 aa와 bb가 참조하는 값이 한번에 달라짐)
							공유변수 int b

*/


public class _01_생성자_중요_이론정리
{
	public static void main(String[] args)
	{
		_01_생성자_중요_이론정리 a=new _01_생성자_중요_이론정리();
		System.out.println(a.toString());
		
	}
}
