package com.sist.main;

/*
		1) 네트워크 프로그램
		2) 데이터베이스 프로그램(★★★★★) => 웹
	------------------------------------------ Spring
	데이터베이스는 데이터 저장 장소
	------------------------ 자바에서 읽기 (메모리에 저장 => 제어)
	1. 메모리에 저장 : <변수> =========> 메모리 제어 : <제어문, 연산자>
	2. 데이터가 많을 경우 : <배열, 클래스>
	3. <클래스>
		1) 클래스 정의 방법 		(객체 지향 프로그램: 여러 클래스의 연결을 통해 작성)  cf) Spring에서는 DI
												=> 행위자 (웹의 경우: 사용자 / 관리자)
			1| 접근지정어: 어디까지 접근 가능한지 지정 (권한 부여)
				-private: 자신의 클래스에서만 사용 가능 (은닉화, 캡슐화 for 데이터 보호) => 변수 (클래스의 속성)
					private 데이터형 변수명;
				-default: 같은 패키지 내에서만 접근 가능
				-protected: 같은 패키지 내에서만 접근 가능 (단, 상속받은 다른 패키지의 경우 사용 가능)
				-public: 모든 클래스와 패키지에서 접근 가능 
						 -클래스: 연관 관계 => 다른 클래스에서 접근이 가능해야 함
						 -생성자: 다른 클래스에서 메모리 할당 후 사용
						 -메소드: 다른 클래스와 통신 담당
					private < default < protected < public
					=> 오버라이딩: 접근지정어의 확장은 가능 (축소 불가)
						ex)
							class A
							{
								public void display(){}
							}
							class B
							{
								void display(){}		==> 오류 why? 상속 받은 클래스의 메소드가 public에서 default로 줄었기 때문
							}														(접근지정어의 축소 불가능)
			2| 형식
				[접근지정어] class 클래스이름 {}
				public class ClassName
				{
				------------------------------------------------------------------
				 속성, 필드 => 멤버변수 (캡슐화): 다른 클래스에서도 접근 가능하게 만들기
				 							Getter/Setter 읽기, 쓰기 메소드
				 공유변수 (static): 패턴 (싱글턴) => 한 개의 객체만 사용
				 		-------- 메모리 공간이 한 개
				 				 공유하는 데이터가 존재할 경우
				------------------------------------------------------------------
				 생성자
				 	-클래스명과 동일
				 	-멤버변수에 대한 초기화
				 	-생성자가 없는 경우, 자동으로 컴파일러가 추가 (기본생성자)
				 	-모든 클래스는 생성자 1개 이상 존재
				 	-생성자는 객체를 생성할 때, 호출되는 메소드 
				 		사용법) new 생성자();
				 	-리턴형이 존재하지 않음 (void도 없음) -> 변수에 대한 초기화 뿐
				 	-필요시 여러 개 생성 가능 ==> 오버로딩 (중복 메소드정의): 한 개의 메소드 이름으로 여러 개의 기능 생성
				 							조건)										ex)
				 								1) 메소드명 동일								class A
				 								2) 한 개의 클래스에서 만듦						{
				 								3) 매개변수의 갯수, 데이터형 달라야 함					//A(){}
				 								4) 리턴형은 관계 없음								A(int a){}
				 																				A(int a, int b){}
				 				cf) 오버로딩 vs 오버라이딩											A(double d){}
				 					 new 	   modify										}  ==> 기본 생성자를 쓰지 않은 상태에서
				 								수정													A a=new A(); --> 오류 (기본생성자 x) 
																													3개의 생성자가 존재하므로
						*** 생성자: 초기화 담당 --> 시작과 동시에 처리하는 일이 있는 경우 ex) 윈도우 디자인 / 웹 메인 / 자동 로그인 / 오라클, 서버 연결 등등...
					*** new (객체 생성 방법)
							class A
						1) A a=new A();
						----------------------------------------
						2) A a=Class.forName("A").newInstance();
						3) A a=A.newInstance();
						---------------------------------------- 리플렉션 (Spring에서 사용하는 방법)
				------------------------------------------------------------------									
				 메소드: 기능을 수행 / 다른 클래스와 연결
				 	형식)
				 		[접근지정어] [제어어] 리턴형 메소드명 (매개변수 목록) <선언부>
				 		{	
				 			<구현부>
				 		}
				 		
				 		<선언부>
				 		-접근지정어: public / default (보통 public)
				 		-제어어: static / final / abstract
				 			static 	-> 객체마다 공통으로 사용되는 기능 (데이터베이스 연결)
				 			final 	-> 오버라이딩 X / Math, String, System => 모든 메소드를 그대로 사용
				 						종단 메소드, 종단 클래스
				 			abstract-> 선언만 하는 메소드 => 프로그램에 맞게 구현해서 사용
				 						ex) 버튼 클릭 
				 					 	추상클래스 / 인터페이스 에서 많이 나옴
				 					 				=> 스프링의 기반 (결합성이 낮은 프로그램)				cf) 형상관리 -> 깃허브
				 		-리턴형: 사용자의 요청을 처리한 결과값 => 한 개만 사용 가능 (기본형 or String)
				 						여러 개의 결과값이 나온다면, 배열 (컬렉션-가변형) 혹은 클래스를 활용
				 				결과값이 없는 경우: 메소드 자체에서 처리 => void
				 		-매개변수: 여러 개 사용 가능 / 사용자가 요청한 값 --> 매개변수의 갯수, 데이터형의 차이로 오버로딩 가능
				 				단! 매개변수는 최소화 시키는 것이 좋음 (3개 이상일 경우, 배열, 클래스를 이용할 것)
				 	
				 		<구현부>
				 		=> 변수가 선언되면, 지역변수 (메소드 종료와 동시에 사라짐)
				 			지역변수는 초기화가 안되므로, 반드시 초기화 후에 사용할 것
				 			
				------------------------------------------------------------------
				this:	클래스마다 this를 가지고 있음 (static)
						자신의 객체 주소를 가지고 있음
						class A
						A a=new A();
					=> JVM이 this에 a 값을 넣어줌 this=a;
					class A
					{
						A()
						{
							this 존재
							display() 가능 (앞에 this. 생략되어있음)
							=> class A 속에서 생성자와 메소드는 A의 생성자와 메소드를 this를 통해서 언제든 사용할 수 있음
								단, static의 경우 메모리 저장 장소가 
						}
						void display()
						{
							this 사용 가능
						}
						static void aaa()
						{
						 	this 존재 x  => why? static은 공유의 영역이므로 1개밖에 존재하지 않음! 따라서 this를 통해 자신의 클래스를 지정할 필요가 없음
							A a=new A(); => 객체 생성 후에 사용 가능
						}
					}
					A a=new A(); => this
					A b=new A(); => this 
					====> this는 멤버변수와 지역변수의 구분
				}
				
			----------------------------------------------------------------------------------
				6장 시작
				=> 재사용 기법
				=> 수정, 추가
				=> 클래스 종류
				------------ 
			   견고한 프로그램 작성
			 재사용 (상속, 포함) / 가독성 (메소드) / 견고성 (예외처리)
			
			194page
			----상속
			
			자바 상속의 특징
			1) 재사용 목적으로 사용 (기존에 만들어진 클래스를 확장해서 사용)
			 ** 필요시에는 변경하여 사용 (오버라이딩)
			 
			2) 반복코딩 제거
				class A
				{
					int a, b, c, d, e;
					void display()
					{
					
					}
					...
					...
					...
				}
				class B extends A
				{
					(class A 존재)
				}
				
			3) 기존에 만들어진 클래스를 확장 -> 새로운 클래스를 만들어 사용
				ex) 
					class 게시판		--> 	class 갤러리게시판 extends 게시판
					{						{			
						글쓰기					글쓰기	-> 이미지 업로드	(덮어쓰기 -> 오버라이딩)
						목록보기					목록보기	-> 이미지 출력
						상세보기					(상세보기	
						수정                		  수정
						삭제                		  삭제
						검색                		  검색)
					}                      	 }		==> 확장을 통해 기존의 것 사용 + 변경, 추가하여 사용
					
					멜론 / 지니 / Mnet ==> 기능이 비슷하므로, 상속을 통해 코드 줄이기 
					
			4) 유지보수용
			5) 단일 상속만 가능
			6) 상속 내리는 클래스: 	부모, 슈퍼, 베이비, 상위 클래스
			   상속을 받는 클래스: 	자식, 서브, 파생, 하위 클래스
				상속이 있는 경우에는 클래스의 크기가 존재함 (형변환)
				=> 상속을 내리는 클래스 > 상속을 받는 클래스
				
				class Super
				class Sub extends Super
				------------------------
				Sub sub=new Sub();		// 확장된 클래스 자체
				Super super=new Sub();	// 하위 클래스를 이용해서 상위 클래스 생성
				------------------------ 인터페이스 / 추상클래스
										 ------------------ 미완성된 클래스
				Sub sub1=(Sub)super;	// 형변환 이후 사용
				------------------------
				
				일반적으로
				클래스 = 생성자 동일
				------------------------
				-> 클래스와 생성자가 다른 경우
				-> 클래스와 메소드 이용
				------------------------인터페이스
				
				List list = new ArrayList()
				Map map=new HashMap()
				-------------------------
				Connection conn=getConnection()
				
				List list = new List() --> 오류 
			
			==> class A
				{
					int a, b;
					void display(){1}
				}
				
				class B extends A
				{
					// int a, b; 		--> 생략된 상태
					int c;
					void display(){2}	--> 오버라이딩 (변경)
				}
				
				A aa=new A();
				aa.a
				aa.b
				aa.display()	=> 1
				
				B bb=new B();
				bb.a
				bb.b
				bb.c
				bb.display()	=> 2
				
				A aaa=new B();
			   ---	  ---
			   변수는 A가 가지고 있는 변수만 사용 가능
			   생성자는 메소드를 제어	==> 즉, 메소드는 B() 생성자를 따라가고 / 변수는 A 클래스 이름을 따라감
				aaa.a
				aaa.b
				aaa.c			=> 사용 불가능 
				aaa.display()	=> 2
				
				상속 예외사항) 생성자 / 초기화블록 / static(공유)
							private: 상속은 되지만, 접근이 안됨 ==> protected 사용 or Getter/Setter 사용

*/

//class Data{
//	private int a;
//
//	public int getA()
//	{
//		return a;
//	}
//
//	public void setA(int a)
//	{
//		this.a = a;
//	}
//}
//
//class Human
//{
//	static Data d=new Data();
//	public void getData(int a)
//	{
//		d.setA(a);
//	}
//	public void print()


//	{
//		System.out.println("d.a= "+d.getA());
//	}
//}

class Super
{
	int a=10;
	int b=20;
	public void display()
	{
		System.out.println("Super가 가지고 있는 display()...");
	}
}
// Super로부터 상속을 받은 Sub
class Sub extends Super
{
	int c=30;
	public void display()
	{
		System.out.println("Sub가 가지고 있는 display()...");
	}
}

public class _01_상속_이론정리
{
	public static void main(String[] args)
	{
		
		Sub sub = new Sub();
		System.out.println(sub.a);
		System.out.println(sub.b);
		System.out.println(sub.c);
		sub.display();
		
		
		
//		Human h=new Human();
//		h.getData(100);
//		h.print();
//		
//		Human h1=new Human();
//		h1.getData(300);
//		h1.print();
//		
//		h.print();
	}
}
