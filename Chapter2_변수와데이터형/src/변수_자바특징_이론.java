/*
	1 장 자바의 특징
	------------
	1. 특징
		1) 운영체제의 독립적 ( 모든 운영체제에 대해 호환성이 좋음 )
		 ex) 윈도우에서 작성 => 리눅스에서 사용 가능 
		 C / C++ => 소스 작성 => compile ( 컴퓨터가 인식하는 언어로 변경 )
		 						.obj 
		 						운영체제마다 다름 (단점)
		 Java => 소스 작성 => compile
		 					.class 운영체제마다 동일한 파일 생성 (장점)
		 	
		 	** 자바 실행 과정
		 	A.java ===========>   A.class     =============> 실행 화면 출력
		 		   컴파일(javac) 바이트(2진파일)  인터프리터, 해석(java)  
				--> 두 번의 검증을 거치므로, 보안이 뛰어남

		2) 객체지향 프로그램 (재사용 편리한 상태) => 유지보수
			재사용 : 수정, 추가, 데이터 보호 (캡슐화)
					------------- 오버라이딩 / 오버로딩
					포함 (수정할 내용이 없을 경우)  ->  has-a
					상속 (수정할 내용이 있을 경우)  ->   is-a
		
		3) 비교적 배우기 쉬움
			C/C++에서 파생 -> 포인터(메모리 주소), 구조체, 다중 상속, 지원하는 API가 미약
				=> 자바언어 => 강력한 API를 가지고 있음 (필요한 기능은 이미 제작이 되어있음)
				=> 조립식 (But! 자바 공부 -> 직접 구현이 필요)
		
		4) 자동 메모리 관리 (가비지 컬렉션)
		
		5) 네트워크 / 분산 / 멀티쓰레드 기능을 가지고 있음.
	
	2. 소스 코딩 방법
		주석 : // => 번역 X (프로그래머만 보는 상태)
		프로그램은 명령어(JVM) => 세미콜론 (;) 하나의 명령 
		대소문자의 구분
		{}을 사용
		들여쓰기 
		== 구성요소
			1) 클래스명 : 첫자는 대문자
			2) 변수 : 소문자 시작
			3) 상수 : 전체가 대문자
			4) 메소드 : 소문자 시작
			5) 생성자: 클래스명과 동일
		
		== 공부
			1) 데이터 저장 방법 : 변수 / 상수
				------------ 메모리 저장 (메모리 크기 결정) => 기본형 (데이터형)
				------------ 사용자 정의 : 참조형 (배열, 클래스)
			2) 데이터 가공
				연산자 / 제어문
			---------------------------------------기본 문법
			3) 관련된 데이터를 모아서 관리 : 배열
			4) 관련된 명령어를 모아서 관리 : 메소드
			5) 데이터 / 명령어를 동시에 관리 : 클래스
			6) 객체 지향 프로그램
			7) 프로그램의 비정상 종료 방지 / 오류 처리 = 예외처리 ex) 계산기 0으로 나눌 경우
			=================================================================== 자바 기본
			8) 자바에서 지원하는 라이브러리 
		
	3. 자바의 구성
		package : 한 번만 사용 => 위치 
		import : 기존에 만들어진 클래스를 불러온다 (여러개)
		------------------------------------------
		class ClassName{
			----------------
				변수 설정
			----------------
				생성자
			----------------
				메소드
			----------------
			  프로그램 시작점
			  public static void main(String[] arg){
			  			기본 문법
			  }
		}
			기본 형식을 익히고 -> 활용 (알고리즘) // 반복.

	
	2장 변수와 연산자
	
	1. 변수: 메모리 내에 데이터가 저장됨 but! 어느 위치에 저장되는지 모르기 때문에, 이름을 부여 -> 변수
			메모리 공간의 별칭
			=> 한 개의 데이터를 저장하는 공간
		
		1) 사용법
			데이터형 + 변수명 = 값(리터럴); (기본 형식)
		
		2) 변수명 식별자 : 하나의 파일 내에 같은 이름의 변수를 사용할 수 없음
			- 알파벳, 한글로 시작 (알파벳은 대소문자 구분)
			- 숫자 사용 가능 (단, 제일 앞에 사용 금지)
			- 특수문자 사용 가능(단, _(언더바)  $(달러) 만 가능)
			 	ex)a_b / _a... (임시변수 혹은 단어가 2개인 경우)
			 	file_name,fileName
			- 키워드는 사용할 수 없음 (자바에서 사용하는 단어)
			 	--> 빨간색으로 표시되는 단어들 ex)public, class, static, int, void
			- 길이의 제한 X but! 사용이 불편하므로 보통 3~7글자 사이
				=> 변수는 약간의 의미 부여가 필요함 why? 보고 알기 편하도록
				    ex) id, name, address, phone ....
			=====================================================
			과일 가게에는 사과 5, 배 10, 바나나 7, 딸기 1 ==> 변하는 값이 4개이므로, 변수 4개
			
			$저장시에는 반드시 앞에 메모리 크기 지정
			기본형(자바에서 지원)
			참조형(사용자 정의) -> 배열 / 클래스
		
		3) 기본형 변수
			- 정수 저장 방법
				1byte : byte    byte a = 10;    // 네트워크 전송 or 파일 읽기
				2byte : short   				// C언어와 호환을 위해.. 거의 사용 x
				4byte : int						// 평상시에 사용하는 모든 정수 (default)
												   --> System.out.println(100) --> 이 경우, 디폴트인 int 사용
												   								  4바이트 사용
				8byte : long					// 바이트 - 메모리를 절약 // 인트 - 최적화 
				           							why? 기본적으로 메모리는 4바이트 단위로 나뉘었기 때문에
			
			- 실수 저장 방법
				4byte : float  -> 소수점 6자리
				8byte : double -> 소수점 15자리 (default)
					ex) 10.5F (float) 10.5D (double) D는 생략 가능
					
			- 문자 저장 방법
				2byte : char
					-> 1byte (싱글바이트 - ASC) / 2bye (멀티바이트 - uniCode)
						cf) 한글, 중국어, 일본어, 독일어 등등 한글자당 2byte (즉, 유니코드)
						byte -> bit(8) -> 256문자 (사용가능한 문자가 적음)
						byte -> bit(16) -> 65535문자 (대부분의 문자를 포함)
						각 문자마다 번호가 부여되어 있음
						컴퓨터는 숫자로 저장하기 때문에 문자를 숫자로 저장
			- 논리 저장 방법
				true / false만 저장 --> 1byte (boolean)
			- 자동 지정 (jdk 10이상)
					var a=10  --> var이 자동으로 int로 바뀜
					var b=10.5  --> var이 자동으로 double로 바뀜
					var c='A'  --> var이 자동으로 char로 바뀜
			
			=> 저장이 가능한 데이터
			byte => -128~127까지 저장 가능
			
			1byte
			
			 128 64  32  16   8   4	  2	 0(1)
			-----------------------------------
			  0	| 1	| 1	| 1	| 1	| 1	| 1	| 1
			-----------------------------------
			 --> 64 + 32 + 16 + 8 + 4 + 2 + 1 = 127
			 범위를 초과할 경우, 에러
			 ex) int a = 128; --> 에러
			부호비트 (0: 양수, 1: 음수)

			2byte => -32768 ~ 32767    => short
			
			4byte => -21억 4천 ~ 21억 4천 => int

			8byte => 그 이상 				=> long
			
			cf) 64비트 컴퓨터 --> 메모리가 8byte씩 나눠짐
			    32비트       --> 메모리가 4byte씩 나눠짐
			    ==> 비트가 높을수록 CPU 성능이 좋아야함 (연산속도가 빨라야 메모리의 데이터를 처리하기 용이)

			변수
			데이터형 변수명 = 값(리터럴);
			----------------------
			단! 값을 부여할 때, 데이터형의 크기에 맞게 할 것.
			 ex) int a = 10.5;
			 	 ---	 ----
			      4 	  8


			데이터형 크기
			byte < short < int < long < float < double
					char
			 	why? float이 long 보다 큰 이유는 숫자 표현이 많기 때문 --> 소수점 아래로 6자리까지 내려가기 때문에

		cf) 클래스 간의 상속에서 화살표 방향이 반대로 되어있음  A ==> B : B에서 A로 상속
		    또한, B 클래스의 크기가 A보다 큼. 



*/
public class 변수_자바특징_이론 {
	
	public static void main(String[] args) {
//		int Ab;
//		Ab = 0;    			 명시적 초기화 --> 직접 입력하여 변수를 고정.
//		System.out.println(Ab);
//		int a = 10000000000; --> int 21억을 넘어간 경우, error 
//		long a = 1000000000;  --> 100억이 인트로 인식되므로, 숫자 뒤에 l을 붙임으로써 long 데이터로 바꿔주어야함.
//		long a = 10.5;  --> long 은 정수형 8byte이지만, 실수형 10.5의 double이 표현할 수 있는 숫자의 총량이 많으므로
//								오류가 발생  --> long a = (long) 10.5; --> 형변환으로 해결
//		int a =123456;
//		double b = 123456.78;
//		int c = (int)((b-a)*100); // 78이 아닌 77 
//		System.out.println(c);  	
		
		byte byte_value =127; 					// 127을 byte_value라는 공간에 첨부하라는 명령
		short short_value=32767;				// 32767을 short_value라는 공간에 첨부하라는 명령
		int int_value=214000000;				// '=' 의 의미 : 오른쪽에서 왼쪽으로 이동
		long long_value=99999999999999l;		// 모든 숫자는 int로 인식  
												// int 와 long의 구분은 l(L)을 통해서
		
		System.out.println(byte_value);
		System.out.println(short_value);   
		System.out.println(int_value);
		System.out.println(long_value);
		
		char char_value='A';
		System.out.println(char_value);
		
		float float_value=10.5f;  				// 실수는 디폴트값이 double이므로, 끝에 f(F)를 붙일 것!
		System.out.println(float_value);
		
		double double_value=10.5;			
		System.out.println(double_value); 	
		
		boolean boolean_value=true;
		System.out.println(boolean_value); 		// byte int long double boolean 5가지 多
		
		// 지역 변수는 반드시 초기값을 부여한 후에 사용이 가능
		
//		변수
//		 = 멤버변수
//		 = 공유변수
//		 ----------- 프로그램 종료시까지 메모리 유지
//		 				=> 자동 초기화
//		 = 지역변수
//		 ----------- 블록이 종료되면 사라지는 변수
//		 				=> 직접 초기화
		
		/*		
		  class A
		  {
		  	----------
		  	멤버변수 / 공유변수
		  	----------
		  	public static void main(String[] arg)
		  	{
		  		-------------
		  			지역변수	--> main(){} 안에서 사용이 가능 --> 반드시 초기화를 해야 함
		  		-------------
		  		}
		  	}
		 	
		 	'변수'는 변경이 가능
		 	'상수'는 변경할 수 없음 (값을 고정)
			
			변수: 데이터형 변수명 = 값; ex) 	int a = 10;
			상수: 데이터형 변수명 = 값; 	   final int b = 20;	
*/
			int kor= 80;			// int kor이 80이라고 선언   cf) kor이 사용되지 않았으므로 경고문이 뜸
			kor=90;					// kor의 값을 변경했음
			kor=100;				// 100으로 변경
			kor=150;				
			System.out.println(kor);
			
			final int SCORE = 70; 		// 변수명을 전부 대문자로 
			//score = 100;  			// 변경할 수 없으므로, 오류 발생
			System.out.println(SCORE);
			
			// = 대입, == 같다, != 같지 않다	(java)
			// = 대입, === 같다, !== 같지않다	(javascript)
			
			/*			
				변수
				선언
				초기화
				
				선언
				int a;
				a=10;
				
				선언과 동시에 초기화
				int a=10;
				
				int a;
				int b;
				int c;
				--> int a,b,c;  여러개를 한 번에 선언할 수 있음
				
				int a = 10;
				int b = 20;
				int c = 30;
				--> int a=10, b=20, c=30;
				
				int a = 10;
				long b = 20;
				double c = 10.5;
				--> 데이터형이 다르므로, 함께 선언할 수 없음
				*/
//				var a = 100;
//				var b = 10.5;
//				var c = 'A';		//jdk 10 이상부터 가능
////				--> 자동 지정 변수 (들어오는 값에 맞춰서 데이터를 결정함)
//				c=97;  // ==> char는 int와 호환이 됨
//				
//				
//				System.out.println(c);	// a가 나옴 why? 97이 a 이므로 (아스키코드)
//						
				int a=10;
				int b=20;
				int temp=a;				// 임시 변수를 사용해야 a의 수가 변할 수 있음.
				a=b; // a=20			// temp에 a 값을 기억시킨 뒤에, a와 b가 같다고 해야 a에 b 값을 넣을 수 있음
				b=temp; // b=20			// 
				System.out.println(a);	// 20   --> a의 값이 b가 되었으므로 20 출력
				System.out.println(b);	// 10	--> b의 값에 temp(10)을 대입했으므로 10 출력 
										// 임시변수
				
				
	}
}
