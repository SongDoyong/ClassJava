package com.sist.exception;

/*
 		<3번 문제 해설>
	final 클래스 => 종단 클래스 (java.lang)
	---------- 확장 불가능 (있는 그대로 사용)	=> 상속 불가능
				상위클래스가 될 수 없음
	java.lang
	java.util
	java.io
	java.net
	java.text
	---------- 자바 기본 라이브러리
	java.sql / javax.http.servlet.* / java.xml....
	오라클 연결	브라우저 연결

		<4번 문제 해설>
	오버라이딩 (상속의 기본) => 변경해서 사용 (다형성)
		객체지향의 3대 요소
		1. 데이터 보호
			-> 캡슐화: 변수의 은닉화 => 메소드를 통해서 접근이 가능하게 만듦
					 ----------					--------
					 private					public
					 => 변수는 2가지 기능만을 수행
					 	1) 메모리에 저장	2) 메모리에서 데이터 읽기
					 	   ----------		--------------
					 	   	Setter				Getter
					 => 모든 멤버변수: private
					 => 모든 메소드(생성자): public 다른 클래스와 연결
				접근지정어
				-------
				1) private: 자신의 클래스에서만 사용 가능 (은닉화)
							다른 클래스에서 접근 불가능
				2) default: 같은 패키지 내에서만 접근 가능
				3) public: 패키지와 상관없이 모든 클래스에서 접근 가능
				
		2. 재사용: 상속 / 포함		===> 클래스 크기가 결정되어 비교 가능 --> 형변환 
			class A			상속
			class B extends A	=>	A가 가지고 있는 모든 내용을 가지고 옴
					------- A의 내용을 변경해서 사용, 추가 가능(오버라이딩)
					라이브러리가 프로그램에 맞지 않는 경우에 수정
				=> 크기 비교:	A(상속을 내린 클래스) > B(상속을 받은 클래스)
							A a=new A(); 
							B b=new B();
							A c=new B(); 자동 형변환
							B d=(B)c;	 강제 형변환
							-----------------------> 추상클래스 / 인터페이스 (메모리 할당이 안됨)
													--------------------
													메모리 할당시에 상속을 받은 클래스를 이용해서 메모리 할당을 한다
													미완성 클래스 (메소드가 구현이 안된 상태)
													=> 설계, 같은 기능 (처리를 프로그램에 맞게 할 때)
															------- 버튼 클릭, 마우스 클릭...
				
			class A
			{
				B b=new B();  포함 -> 특별한 경우가 아니면, 재정의하지 않음 -> 있는 그대로 가져다 쓰기
			}							ex) Scanner scan=new Scanner();
			class B				
						
		3. 수정, 추가
			수정(오버라이딩) / 추가(오버로딩)
			---------------------------------------------------------
								오버로딩				오버라이딩
			---------------------------------------------------------
			관계				한 개의 클래스				상속관계
							상속관계
			---------------------------------------------------------
			메소드명			동일해야함					동일해야함
			---------------------------------------------------------
			매개변수		갯수, 데이터형이 달라야함			동일해야함
			---------------------------------------------------------
			리턴형			관계없음					동일해야함
			---------------------------------------------------------
			접근지정어			관계없음					확장 가능
			---------------------------------------------------------
			사용처			생성자				인터페이스 / 추상클래스
			---------------------------------------------------------
			
			*** 상속
				1) 호출	 	=> 상위클래스의 생성자가 먼저 호출 (기본생성자)
							class A
							{
								public A(int a){
								}
							}
							class B extends A
							{
								public B(int a, int b){
								}
							}
							B b=new B(); 	==> new A() 먼저 생성 후, new B() --> but! class A에 기본생성자가 없으므로, 오류
												기본생성자로 A()가 생성되지 않음 --> int a가 없기때문.
												A() -> super / B() -> this
				2) 상속의 예외조건
					: static / 생성자 / 초기화블럭 / private
		
			<7번 문제 해설>
		클래스의 종류
		----------
		추상클래스
		인터페이스: 추상클래스의 단점 보완(클래스와 동일하게 취급)
				클래스: 단일상속 / 인터페이스: 다중상속
		------- 설계도 (구현이 안된 상태): 미완성 클래스(자신이 메모리 할당을 할 수 없음)
							==> 상속을 내린 후, 구현해서 사용해야함
		------- 여러 개의 관련된 클래스를 모아서 한 개의 객체명으로 제어하기 위해 사용
				
						추상클래스					인터페이스
		---------------------------------------------------------------
		상속관계			단일 상속					다중상속
		---------------------------------------------------------------
		상속키워드			extends					implements
		---------------------------------------------------------------
		멤버변수		인스턴스변수, 클래스변수			상수형 변수만 사용
		---------------------------------------------------------------
		메소드	구현된 메소드						구현되지 않은 메소드만				
				구현되지 않은 메소드
		---------------------------------------------------------------
		용도				오버라이딩					오버라이딩
		---------------------------------------------------------------
		형식		
		
		[접근지정어] abstract class ClassName		[접근지정어] interface 인터페이스명 
		{										{
			-------------------------				------------------------
			변수    인스턴스 변수						변수선언 (상수형 변수만 가능)
				   static 변수						int a=10; (명시적 값 지정 필수)
			-------------------------			=> (public static final) int a=10;
		메소드  		구현된 메소드						------------------------
			[접근지정어] 리턴형 메소드명(매개변수)		메소드		선언만 된 메소드	
			{												void display();
			}									=> (public abstract) void dispaly();
				  선언만 된 메소드								구현된 메소드
	[접근지정어] abstract 리턴형 메소드명(매개변수);		(public) default void aaa(){} --> default 붙이기
			-------------------------				(public) static void bbb(){}	--> static 붙이기
			생성자 (오버로딩 가능)						------------------------
			-------------------------			=> 인터페이스는 변수, 메소드가 public (연결 목적이기 때문)
		}
		---------------------------------------------------------------
		
		상속
		interface B extends interface A
		class C implements interface A
		다중상속
		class D implements A, B
		
		*자바 메모리구조
  JVM ---|--정적 영역: Method Area / static
(전체관리) |--stack 영역: 지역변수 / 매개변수 --> 메모리 자체 관리--> {}가 종료되면 자동 소멸
		 |--heap 영역: 객체 / 배열 / 인터페이스 / 열거형 --> 프로그래머 관리 영역(GC) ==> 사용이 없는 경우 or null인 경우
		 
		 <10번 문제 해설>
	-필드: 멤버변수를 의미
	-생성자의 역할: 객체 생성시 호출 / 멤버변수에 대한 초기화 
	-생성자의 특징: 클래스명과 동일 / 리턴형 없음 / 접근지정어는 보통 public / 오버로딩 지원 (여러 개의 생성자 가능)  
		
		<11번 문제 해설>
	Object는 최상위 클래스
	Object o=new A();
	--> o는 A의 변수는 사용 불가, 메소드는 재정의된 메소드만 사용 가능
			A a=new B() ==> A에 있는 데이터만 사용, 메소드는 변경된 것만 사용
			하위 클래스에서 추가된 메소드, 변수는 사용할 수 없다.

		<12번 문제 해설>
	private은 상속을 받아도 사용할 수 없다
	--> 사용하려면, getter/setter 메소드
	
		<14번 문제 해설>
	protected void()가 상속 내린 클래스에서 default void()로 축소되었음 --> 확장은 가능하나, 축소는 불가능
	
	
*/
abstract class C
{
	C(){
		
	}
	C(int a){
		
	}

}

class A
{
	int a=10;
	String name="홍";
	public A() {		// default 생성자가 있어야 상속을 내렸을 때, 상속받은 클래스에서 상속을 내린 클래스를 생성할 수 있음	
		
	}
	public A(int a) {
		this.a=a;
	}
}
class B extends A
{
	int b=20;
	public B()
	{
		super(); 		// 상위 클래스의 생성자를 보이진 않지만 생성하고 있음. --> 상위 클래스에서 기본 생성자가 없으면 오류
	}
}
public class _01_7장정리
{
	public static void main(String[] args)
	{
		A a=new B();
		B b=(B)a;
//		B b=(B)new A();
		String s1="Hello";							//	"Hello"라는 문자열은 하나의 주소를 가지고 있음 
		String s2="Hello";							//	
		String s3=new String("Hello");				 // 단! new를 사용하면, 새로운 메모리 주소가 생성됨
		
		if(s1==s2)
		{
			System.out.println("같다(참조주소)");
		}
		
	}
}
