package com.sist.main;

/*
 
 									< 자바 실행구조 >
 									
 				A.java		===>	A.class		===>	01010101010(컴퓨터언어)	
 				원시언어		javac  자바바이트코드	java		기계어	
 			  자바소스코드		컴파일러			   인터프리터
 			  									JVM
 			
 									
 									<	메모리 구조   >
 									
 				---------------------------------------------------------
							<	Method Area (static)  >
				=> 컴파일러가 자동 저장
				=> method도 메모리에 저장
					void method()
				{
				 메소드는 구현부가 있어야 저장됨
				}
				=> 메소드 선언만 된 경우, 클래스를 저장하지 못함 (미완성된 클래스)
					< 추상클래스, 인터페이스 > ? 요구사항 분석시 사용
								------- 데이터베이스 연결, 윈도우, 네트워크 서버, 웹 구현
					void method(); (선언만 된 경우)
 				---------------------------------------------------------
								<	Stack: LIFO   >
				=> 지역변수, 매개변수 저장 --> 메모리 자체에서 관리 -->{} 종료시 사라짐
					class A			
					{			
						void method()			
						{			
							int a=10;			
							if(a%2==0)			
							{			
								int b=20;			
								if(b==20)			
								{			
									int c=30;			
								} 	// c 사라짐			
							}		// b 사라짐			
						}			// a 사라짐			
					}		=> 마지막에 들어온게 먼저 나감 (Last In First Out)			
 				---------------------------------------------------------
 									<	Heap   >
 				=> 동적 메모리 할당 (new) --> interpreter(번역기) -> 한 줄씩 번역
 					(프로그래머의 관리) Garbage Collection이 자동으로 메모리를 해제하지만,
 									완전하지 않기 때문에, 직접 해체해야함
 				
 				class
 				{
 				 ~~~~~~~
 				 ~~~~~~~ new -->  위에서부터 한 줄씩 읽다가 new가 발생하면
 				 ~~~~~~~							새로운 메모리 공간 생성
 				 ~~~~~~~
 				}
 				---------------------------------------------------------
 
 							
 							
 							<데이터 저장 구조>
 							
 		변수 => stack에 저장
 		ex)
 			int a=10;								==> 배열과 클래스도 주소를 부여하고(생성),  
 			0---------------								병렬로 연결된 데이터의 집합에 이름 부여 (배열명, 클래스명)
 				사용중
 			4---------------
 				사용중
 			8---------------
 				a --> 어디 있는지 모름 
 					--> 메모리 주소에 대한 이름 부여 
 						--> 이름 = 변수
 			12---------------
 		
 
 (지역변수 --> 메소드 {} 속에 생성되는 변수 --> 메소드가 기능을 수행하는 동안 생성되었다가, 메소드의 종료와 동시에 사라지는 변수)
 (매개변수 --> 메소드를 사용하기 위해, 사용자가 값을 입력 --> 그 값은 지역변수, 제어문들과의 상호작용을 통해 최종 값을 만들어냄)
 	변수 60 / 메소드 30 / 생성자 5
 
		클래스
		-----
		1. 구성요소
			1) 변수
				-인스턴스변수: 객체마다 메모리를 따로 저장 
						=> new를 이용해서 메모리 저장공간을 만들어서 사용
							A a=new A();
							인스턴스 (객체)
							<a.변수명>을 통해 사용
				-정적변수: 메모리 공간이 1개 (공유변수, static변수, 클래스변수)
						=> 컴파일시 자동으로 생성
							<클래스명.변수명>을 통해 사용
				-지역변수: 기능 처리에 필요한 데이터를 설정 (메소드 종료와 동시에 사라짐)
				-매개변수: 사용자 요청값 => 메소드 종료와 동시에 사라짐
			------------ 변수는 반드시 초기화 후에 사용
									---- 자동초기화: 클래스 영역에 선언된 변수 - 멤버변수(instance 인스턴스) / 정적변수(static 스태틱)
										 수동초기화: 지역변수, 매개변수
					class A
					{
						String addr;						주소를 받아서, 지도를 출력하는 프로그램
						void Address(String addr)			1) 주소 필요 ---> 변수 선언 
						{									2) 사용자 요청값인 addr(지역변수)을 멤버변수 this.addr에 저장 	
							this.addr=addr;							why? 입력받은 addr이 메소드 종료와 동시에 사라지므로, 
						}												사라지지 않는 멤버변수(인스턴스)에 저장
						void 지도출력()
						{
						
						}
						void 근처맛집()
					}
					
			2) 메소드: 명령문의 집합 => 단락 (구조적인 프로그램)
					 	반복수행 (제거) => 재사용 (한가지 기능 수행)
			
				 종류
					-인스턴스 메소드: 따로 작동하는 메소드
						String s="Hello Java";
						s.substring(); --> 문자열마다 따로 작용하는 메소드 (인스턴스 메소드)
						String s1="Hello Oracle";
						s1.substring(); --> 제어하는 대상이 없음
					-정적 메소드: 동시에 작동 (static -> 자동 저장)
						10 => "10" / true => "true"  
						String.valueOf(데이터형) --> 어떤 대상이 오던 String으로 변환 (정적 메소드)
						Math.random()		   --> 제어하는 대상 없이 난수발생 
					-추상 메소드: 설계 --> 모든 개발자가 같은 메소드를 제어
										(표준화 작업) => 여러 개의 클래스를 묶어서 한 개의 이름으로 제어
					-종단 메소드: final void aaa() --> 변경할 수 없는 메소드 (확장 불가)
					
			3) 생성자
					-사용목적 1: 객체 생성시 호출되는 메소드 --> A a= new A(); 
					-사용목적 2: 멤버변수의 초기화	--> A(){}	
					-특징
						클래스명과 동일
						리턴형 x 
						여러 개 존재 가능 (오버로딩)
						클래스 안에 생성자를 반드시 구현하는 것은 아님 --> 컴파일러가 기본생성자를 자동으로 생성하므로
				=변수만 모아서 관리: 사용자 정의 데이터형 (~VO, ~DTO, ~Bean)
					Getter/Setter는 메소드 (변수의 기능: 읽기, 쓰기)
				=메소드만 모아서 관리: 액션 클래스 (~System, ~DAO, ~Manaber, ~Service)
				=변수+메소드: 조립시 (~Model, ~Controller, ~Action)
						
		2. 클래스 설계
			1) 기능 설계: 메소드 추출
			2) 기능에서 사용하는 변수 추출
			3) 클래스 설계
				class ClassName
				{
					변수
					메소드
					생성자
				}
			4) 메모리 저장
				ClassName c = new Classname();
			5) 활용
				c.메소드...
			6) 소멸
				c=null;
		3. 접근지정어
			---------------------------------------------------
			private: 자신의 클래스 내에서만 접근 가능 => 데이터보호 (캡슐화)
			---------------------------------------------------
			default: 같은 패키지 내에서만 접근 가능
			---------------------------------------------------
			protected: 같은 패키지 내에서만 접근 가능 (상속받은 다른 패키지도 가능)
			---------------------------------------------------
			public: 모든 패키지와 클래스에서 접근 가능
			---------------------------------------------------
			멤버변수: [접근지정어] 데이터형 변수명
			메소드: [접근지정어] [제어어] 리턴형 메소드명 (매개변수 목록) { }
							 ------ static / abstract / final
			
		4. 객체지향의 특성 
			1) 캡슐화: 데이터를 은닉화한 후에 메소드를 통해 접근
					  (private)			(Getter/Setter)
			2) 재사용: 상속(is-1)과 포함(has-a)을 통해 클래스의 재사용
					상속- 기존의 기능을 변경해서 사용
					class A { } --> class B extends A { }  / 단일상속만 가능
					포함- 기존의 기능을 있는 그대로 사용
					class A { } --> class B { A a; }		/ 클래스 자체를 new해서 사용 ex) Scanner scan = new Scanner();
			3) 다형성: 수정(오버라이딩) / 추가(오버로딩)
			
		5. 제어자
			static / abstract / final
		=> static / abstract: 상수
		=> final: 상수형 변수	==> 메소드 안에서 사용 가능
		  ------- 사용하는 우치 (오라클 주소, 계정명, 비밀번호)





*/
public class _01_객체지향정리
{
	public static void main(String[] args)
	{
		
	}
}
